#큰 수의 법칙

예제

큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4인 28이 도출된다.
배열의 크기가 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력하시오.

입력 조건

첫째 줄에 N(2<=N<=1,000), M(1<=M<=10,000), K(1<=K<=10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의자연수는 1 이상 10,000 이하의 수로 주어진다.
입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력 조건

첫째 줄에 큰 수의 법칙에 따라 더해진 답을 출력한다.

입력 예시

5 8 3

2 4 5 4 6

출력 예시
46

---

입력값으로 만들수 있는 최대값을 구하는 방법으로 전형적인 그리디 알고리즘이다.
해당 문제의 경우 조건에 따라 입력받은 값들중 가장 큰 값과, 그 다음으로
큰 값을 구한후 주어진 조건에 따라 합을 구하는 알고리즘이다. 

```python
import sys

n, m, k = list(map(int, input().split()))
arr = list(map(int, input().split()))
arr.sort(reverse=True)

sum = 0
cnt = k
for i in range(m):
    if(cnt==0):
    cnt=k
    sum+=arr[1]
    continue
sum+=arr[0]
cnt-=1
print(sum)
```

일반적으로 위와 같은 알고리즘 풀이법을 먼저 떠오를 수 있지만 위 방법의 경우 m<=10000이기에
제한시간 내에 해결할 수 있지만 m>100억 이라면 시간 초과가 뜬다. 따라서 수학적 아이디어로 
좀 더 효율적으로 해결할 수 있다.

가령 m=8, k=3, 리스트가 [2,4,5,4,6] 인 경우...
가장 큰 수:6
두 번째로 큰 수:5

|*1*|*2*|*3*|*4*|
|---|---|---|---|
|6|6|6|5|

|*1*|*2*|*3*|*4*|
|---|---|---|---|
|6|6|6|5|

**...**

규칙에 따라 6이 3번 반복된 후 5가 한번 나오는 방식의 *수열이 반복* 됨을 확인할 수 있다.

수열의 길이는 k+1이고 수열이 반복되는 횟수는 M/(k+1) 이고 여기에 k를 곱해주면 가장 큰 수가 등장하는 횟수가 된다. 이때 m이 (k+1)로 나눠지지 않는 경우를 고려해야 하는데 이럴 때는 m을 (k+1)로 나눈 나머지 만큼 가장 큰 수가 추가적으로 더해진다.

따라서 다음 내용을 수식으로 옯기면 아래와 같다.
```python
int(m/(k+1))* k + M%(k+1)
```
해당 수식을 반영한 코드는 big_number_rule.py에서 확인 가능하다.